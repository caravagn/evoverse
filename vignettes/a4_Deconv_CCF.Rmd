---
title: "Pipeline 4. Subclonal deconvolution by CCF"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Subclonal deconvolution by CCF}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=F, warning=F}
library(evoverse)
```

# Pipeline overview 

<img src="pipeline_CCF.png" alt="drawing" height="100"/>

**Main function: ** ``pipeline_subclonal_deconvolution_CCF`.

## Input requirements

The following data are required to run this pipeline.

* one [CNAqc](https://caravagn.github.io/CNAqc/) input dataset, which consists of: 
  * somatic mutations (with read counts data), `mutations`;
  * absolute copy number segments, `cna`;
  * tumour purity, `purity`;
  * a genome reference supported by [CNAqc](https://caravagn.github.io/CNAqc/).
  
* a list `karyotypes` of shorthands (in `Major:minor` notation) for karyotypes that should be used to compute CCF for subclonal deconvolution. 
    - By default, `c('1:0', '1:1, '2:0', '2:1', '2:2')` are used; 

* pipeline parameters, which allow to:
   * impose a minimum VAF on the data to analyse, `min_VAF`;
   * impose a mimumin (`min_muts`) and maximum (`N_max`) for the number of mutations to analyse;
   * identify a run by a `description`;
   * decide how CCF should be [computed by CNAqc](https://caravagn.github.io/CNAqc/articles/a4_ccf_computation.html), `CCF_computation`;
   * forward parameters to customise the fit(s), using an ellypsis. 
   
The input format of input data is [discussed in a CNAqc vignette.](https://caravagn.github.io/CNAqc/articles/Introduction.html).  


## Pipeline skeleton

The following steps are performed by `pipeline_subclonal_deconvolution_CCF`.

1. input mutations are mapped to copy number segments, integrating also tumour purity using [CNAqc](https://caravagn.github.io/CNAqc/). 

2. input mutations are subset according to the required input list of karyotypes; mutations that map to karyotypes with less than the required number of mutations (pipeline input), are disregarded by the analysis. CCF estimates are computed from all the remaining mutations, and the [QC score from CNAqc](https://caravagn.github.io/CNAqc/articles/a4_ccf_computation.html) is used to determine which karyotypes can be associated to mutations with reliable CCF values. Only karyotypes with QC `"PASS"` are retained.

3. [MOBSTER](https://caravagn.github.io/mobster/) is used to perform deconvolution from _adjusted CCF values_ (i.e., clonal peaks at 50% value, to avoid truncations); the following procedure is followed for each karyotype:

   * a first run of `mobster_fit` is performed forwarding the ellipsis parameters to the function call;
   
   * the [deconvolution classifier](https://caravagn.github.io/evoverse/articles/1_qc_models.html) of `evoverse` is used to determine a QC `"PASS"` or `"FAIL"` status for the run;
   
      * If the status is `"PASS"`, the deconvolution with this karyotype is completed. 
      * If the status is `"FAIL"`, a second run is computed using `mobster`'s default parameters; the QC is re-computed for the new run and that is considered the final result. 

4. Compute output tables:
   * one summary table  reporting the generated fits and their QC scores;
   * one assignment table with the assignements for each one of the analysed mutations.

5. Determine the final estimate of the tumour clonal architecture (`"Monoclonal"` vs `"Polyclonal"`), and the overall QC `"PASS"`/ `"FAIL"` of this analysis. 

### Architecture estimation

The rationale to determine the clonality of the input sample is simple. Since CCF are computed only from for those karyotypes that pass the QC analysis with [CNAqc](https://caravagn.github.io/CNAqc/articles/a3_peaks_detection.html), the overall QC of the analysis and tumour clonality are estimated from the analysis done with [MOBSTER](https://caravagn.github.io/mobster).

The rationale to determine the tumour architecture is the same adopted in other pipelines. We consider the snumber of Binomial components (`BMix_K_B`) that fit non-tail mutations with [BMix](https://caravagn.github.io/BMix), after [MOBSTER](https://caravagn.github.io/mobster). The `case_when` diagram is this.
```{r, eval=FALSE}
case_when(
  BMix_K_B  > 1 ~ "Polyclonal",
  BMix_K_B  == 1 ~ "Monoclonal"
)
```
   
In the unfortunates case that all karyotypes `"FAIL"` CCF computation (poor quality data), the architecture cannot be determined and an overall QC `"FAIL"` is assigned to this analysis.

# Example run

```{r, eval=F}
# Use example data in the CNAqc package
data(example_dataset_CNAqc, package = 'CNAqc')

pipeline = pipeline_subclonal_deconvolution_CCF(
  mutations = CNAqc::example_dataset_CNAqc$snvs,  # Somatic mutations
  cna = CNAqc::example_dataset_CNAqc$cna,         # Copy number segments
  purity = CNAqc::example_dataset_CNAqc$purity,   # Sample purity
  reference = 'GRCh38',                           # Genome reference
  N_max = 10000,                                  # Downsample karyotypes with > 10K mutations (none here)
  min_muts = 150,                                 # Minimum number of mutations per karyotype
  min_VAF = 0.05,                                 # Minimum VAF 
  ccf_method = 'ENTROPY'                          # CCF computation
  description = "Example CNAqc",                  # Dataset description
  auto_setup = 'FAST'                             # Ellipsis (parameters forwarded to each mobster first run)
)
```

S3 output object
```{r, eval=F}
print(pipeline)
```

Output fields
```{r, eval=F}
# MOBSTER fits per karyotype
print(pipeline$mobster)

# BMix fits per karyotype
print(pipeline$bmix)

# Clustering assignments
print(pipeline$table$clustering_assignments)

# Summary QC
print(pipeline$table$summary)
```

One-page plotting function (assembles a multi-panel figure)
```{r, fig.width=15, fig.height=15, eval=F}
plot(pipeline)
```
