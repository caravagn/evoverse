---
title: "Pipeline 1. Data quality check"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data quality check}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=F, warning=F}
library(evoverse)
```

# Pipeline overview 

<img src="pipeline_qc.png" alt="drawing" height="100"/>

**Main function: ** ``pipeline_qc_copynumbercalls`.

## Input requirements

  * somatic mutations (with read counts data), `mutations`;
  * absolute copy number segments, `cna`;
  * tumour purity, `purity`;
  * a genome reference supported by [CNAqc](https://caravagn.github.io/CNAqc/).
  
  A [CNAqc](https://caravagn.github.io/CNAqc/) object with these data is created. 

  * Computation:
  ** load data for a run;
  ** [smooth](https://caravagn.github.io/CNAqcarticles/a5_smoothing.html) input CNA segments;
  ** perform  [peak detection analysis](https://caravagn.github.io/CNAqc/articles/a3_peaks_detection.html);
   * decide how CCF should be [computed by CNAqc](https://caravagn.github.io/CNAqc/articles/a4_ccf_computation.html), `CCF_computation`;


## Pipeline skeleton

The following steps are performed by `pipeline_qc_copynumbercalls`.

1. input mutations are mapped to copy number segments, integrating also tumour purity using [CNAqc](https://caravagn.github.io/CNAqc/); if required input segments are [smoothed](https://caravagn.github.io/CNAqcarticles/a5_smoothing.html).

2. [peak-detection](https://caravagn.github.io/CNAqc/articles/a3_peaks_detection.html) is used to determine the quality of each karyotype, with a QC `"PASS"` or `"FAIL"` assessment;

3. [CCFs are computed](https://caravagn.github.io/CNAqc/articles/a4_ccf_computation.html), with a QC `"PASS"` or `"FAIL"` assessment per karyotype;

4. [Arm-level fragmentation](https://caravagn.github.io/CNAqc/articles/a6_fragmentation.html) is used to determine chromosome arms that seem to have an excess of small fragments;

4. On output table is computed to report QC results from all data.

# Example run

```{r, cache=TRUE, eval=TRUE}
# Use example data in the CNAqc package
data(example_dataset_CNAqc, package = 'CNAqc')

pipeline = pipeline_qc_copynumbercalls(
  mutations = CNAqc::example_dataset_CNAqc$snvs,  # Somatic mutations
  cna = CNAqc::example_dataset_CNAqc$cna,         # Copy number segments
  purity = CNAqc::example_dataset_CNAqc$purity,   # Sample purity
  reference = 'GRCh38',                           # Genome reference
  description = "Example dataset for QC",         # Dataset description
  smooth = TRUE,                                  # Smooth copy number segments
  matching_epsilon_peaks = 0.025,                 # Peak-detection parameters
  ccf_method = 'ENTROPY'                          # CCF computation
  )
```

## Extracting output information

A special S3 output object is used to store results from this pipeline; the object implements methods for `print` and `plot`.

```{r, eval=TRUE}
# S3 object
class(pipeline)

# Summary of the results
print(pipeline)
```


The fields `pipeline$cnaqc` is the [CNAqc](https://caravagn.github.io/CNAqc/) object computed by the pipeline; it contains CCF, peaks analysis etc. and can be accessed with the [methods of the package](https://caravagn.github.io/CNAqc/).

```{r, eval=TRUE}
# CNAqc object
print(pipeline$cnaqc)
```


A summary QC table of the pipeline can be accessed; scores `f_PASS` and `NA_test` are percentages of tests that have achieved QC `"PASS"`, and tests that could not be computed (because of constraints of parameters, or missing data etc.) 

```{r, eval=TRUE}
print(pipeline$QC)
```

## Plots

A multi-panel figure is assembled by the S3 `plot` method, wich reports (by row) CNA segments and genome-wide depth of sequencing, CCF and raw data histograms, results from peak-detection and a strip plot of mutation multiplicity estimates that are used to compute CCFs.

```{r, fig.width=10, fig.height=11, eval=TRUE}
plot(pipeline)
```
