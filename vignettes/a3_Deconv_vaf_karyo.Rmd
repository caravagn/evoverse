---
title: "Pipeline 3. Subclonal deconvolution by VAF and karyotypes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Subclonal deconvolution by VAF and karyotypes}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=F, warning=F}
library(evoverse)
```

# Pipeline overview 

<img src="pipeline_vaf_karyo.png" alt="drawing" height="100"/>

**Main function: ** ``pipeline_subclonal_deconvolution_VAF_karyotype`.

## Input requirements

The followind data are required to run this pipeline.

* one [CNAqc](https://caravagn.github.io/CNAqc/) input dataset, which consists of: 
  * somatic mutations (with read counts data), `mutations`;
  * absolute copy number segments, `cna`;
  * tumour purity, `purity`;
  * a genome reference supported by [CNAqc](https://caravagn.github.io/CNAqc/).
  
* a list `karyotypes` of shorthands (in `Major:minor` notation) for karyotypes that should be used to perform subclonal deconvolution. 
    - By default, `c('1:0', '1:1, '2:0', '2:1', '2:2')` are used; 

* pipeline parameters, which allow to:
   * impose a minimum VAF on the data to analyse, `min_VAF`;
   * impose a mimumin (`min_muts`) and maximum (`N_max`) for the number of mutations to analyse;
   * identify a run by a `description`;
   * forward parameters to customise the fit(s), using an ellypsis. 
   
The input format of input data is [discussed in a CNAqc vignette.](https://caravagn.github.io/CNAqc/articles/Introduction.html).  


## Pipeline skeleton

The following steps are performed by `pipeline_subclonal_deconvolution_VAF_karyotype`.

1. input mutations are mapped to copy number segments, integrating also tumour purity using [CNAqc](https://caravagn.github.io/CNAqc/);

2. input mutations are subset according to the required input list of karyotypes; mutations that map to karyotypes with less than the required number of mutations (pipeline input), are disregarded by the analysis.

3. [MOBSTER](https://caravagn.github.io/mobster/) is used to perform deconvolution from _raw VAF data of each karyotype_; the following procedure is followed for each karyotype:

   * a first run of `mobster_fit` is performed forwarding the ellipsis parameters to the function call;
   
   * the [deconvolution classifier](https://caravagn.github.io/evoverse/docs/articles/1_qc_models.html) of `evoverse` is used to determine a QC `"PASS"` or `"FAIL"` status for the run;
   
      * If the status is `"PASS"`, the deconvolution with this karyotype is completed. 
      * If the status is `"FAIL"`, a second run is computed using `mobster`'s default parameters; the QC is re-computed for the new run and that is considered the final result. 

4. Compute output tables:
   * one summary table  reporting the generated fits and their QC scores;
   * one assignment table with the assignements for each one of the analysed mutations.

5. Determine the final estimate of the tumour clonal architecture (`"Monoclonal"` vs `"Polyclonal"`), and the overall QC `"PASS"`/ `"FAIL"` of this analysis. 

### Architecture estimation

The rationale to determine the clonality of the input sample is as follows:

* For each karyotype analysed, a QC `"PASS"` or `"FAIL"` score is obtained by [peak detection from CNAqc](https://caravagn.github.io/CNAqc/articles/a3_peaks_detection.html). 
* For each [MOBSTER](https://caravagn.github.io/mobster) fit, a QC `"PASS"` or `"FAIL"` score is obtained by the [deconvolution classifier](https://caravagn.github.io/evoverse/docs/articles/1_qc_models.html).

This joint classification can be used to assess the quality of the input data and the fits. Karyotypes that `"PASS"` both QCs are used to determine the architecture, with an overall decision that is taken considering the number of mutations in each karyotype. In this cases, an overall QC `"PASS"` is assigned to this analysis.


* Example:  80% of mutations in diploid regions (`karyotype = "1:1"`) suggest a `"Monoclonal"` tumour, but 20% in genome-doubled regions (`karyotype = "2:2"`) suggest `"Polyclonal"`: the overall decision is dominated by diploid mutations 

To determine the clonality of a fit we consider the input `karyotype`, and the number of Binomial components (`BMix_K_B`) that fit non-tail mutations with [BMix](https://caravagn.github.io/BMix), after [MOBSTER](https://caravagn.github.io/mobster). The `case_when` diagram is this.
```{r, eval=FALSE}
case_when(
  karyotype %in% c("1:0", "1:1") & BMix_K_B  > 1 ~ "Polyclonal",
  karyotype %in% c("1:0", "1:1") & BMix_K_B  == 1 ~ "Monoclonal",
  karyotype %in% c("2:0", "2:1", "2:2") & BMix_K_B  > 2 ~ "Polyclonal",
  karyotype %in% c("2:0", "2:1", "2:2") & BMix_K_B  <= 2 ~ "Monoclonal"
)
```
   
In the unfortunates case that all karyotypes `"FAIL"` peak detection (poor quality data), the architecture cannot be determined and an overall QC `"FAIL"` is assigned to this analysis.


# Example run

```{r, eval=F}
# Use example data in the CNAqc package
data(example_dataset_CNAqc, package = 'CNAqc')

pipeline = pipeline_subclonal_deconvolution_VAF_karyotype(
  mutations = CNAqc::example_dataset_CNAqc$snvs,  # Somatic mutations
  cna = CNAqc::example_dataset_CNAqc$cna,         # Copy number segments
  purity = CNAqc::example_dataset_CNAqc$purity,   # Sample purity
  reference = 'GRCh38',                           # Genome reference
  N_max = 10000,                                  # Downsample karyotypes with > 10K mutations (none here)
  min_muts = 150,                                 # Minimum number of mutations per karyotype
  min_VAF = 0.05,                                 # Minimum VAF 
  description = "Example CNAqc",                  # Dataset description
  auto_setup = 'FAST'                             # Ellipsis (parameters forwarded to each mobster first run)
)
```

S3 output object
```{r, eval=F}
print(pipeline)
```

Output fields
```{r, eval=F}
# MOBSTER fits per karyotype
print(pipeline$mobster)

# BMix fits per karyotype
print(pipeline$bmix)

# Clustering assignments
print(pipeline$table$clustering_assignments)

# Summary QC
print(pipeline$table$summary)
```

One-page plotting function (assembles a multi-panel figure)
```{r, fig.width=15, fig.height=15, eval=F}
plot(pipeline)
```
